​                                                                     

# chapter 2

이 챕터에서는 커널의 초기 부팅 과정을 담당하는 head.S와 런타임 중에 발생하는 익셉션을 처리하는 익셉션 핸들링 코드에 대해서 다룬다



## 2.0

32비트와 64비트 커널은 가상 주소 공간의 크기가 다르다

- 32비트

  **전체 주소 공간을 유저 주소 공간과 커널 주소 공간으로 분할하여 사용한다** -> 3G/1G, 2G/2G, 1G/3G중 하나로 분할한다

- 64비트

  **전체 주소 공간이 다 매핑되지 않는다**. 유저 주소 공간과 커널 주소 공간의 크기는 *CONFIG_ARM64_VA_BITS*에 의해 동일한 사이즈로 결정된다. **유저 주소 공간은 0번지**에서 시작하고 **커널 주소 공간은 주소 공간의 끝**에 위치한다. **공간의 크기는 주소 변환 단위인 페이지 크기에 따라 달라진다**.

  > 아직 왜 페이지 크기에 영향을 받는 것인지 이해를 하지 못했다. 마찬가지로 아래의 계산도 이해하지 못했다.

  *ARM64_4K_PAGES*를 기본 값으로 선택하는데 *VA_BITS*는 39비트가 된다.



## 2.1 커널의 진입점 head.S

`head.S`는 **CPU의 초기화**를 담당한다.

**ARM64 커널의 실행 조건**은 다음과 같이 정의되어 있다.

- MMU는 꺼져 있을 것
- 데이터 캐시는 꺼져 있을 것(인스트럭션은 상관X)
- x0 레지스터는 FDT 바이너리의 물리 주소를 가르킬것

EFI 관련 코드를 제외하면 `stext`에서 시작하며 stext의 실행 흐름은 다음과 같다.

1. 부트 파라미터 저장
2. EL2로 진입했을 경우 EL2 설정
3. 커널 이미지의 가상 주소와 물리 주소 사이 오프셋 계산
4. 커널을 위한 페이지 테이블 설정
5. 프로세서 초기화
6. MMU 활성화
7. start_kernel로 점프

stext 프로시저는 **ENTRY(심볼 이름)** ~ **ENDPROC(심볼 이름)**의 형태로 둘러싸여 있다. *ENTRY*는 심볼을 링커에게 제공(.global)하고 심볼을 정렬(.align)한다. *ENDPROC*은 심볼이 함수임을 알려주고 심볼의 크기를 계산한다.

### 2.1.1 부트 파라미터 저장

*preserve_boot_args* 프로시저는 커널 부팅을 위해 전달된 부트 파라미터를 저장한다. *`x0`* 레지스터만 `dtb(device tree blob)의 물리주소`로 명시된다. MMU가 꺼진 상태에서 저장 명령 이후에 캐시가 정리되도록 메모리 베리어를 사용한다.(*dmb sy*). *__inval_cache_range*을 통해 x0, x1 레지스터가 가리키는 메모리 영역의 캐시를 무효화한다.(*boot_args*에 저장한 메모리 영역)

### 2.1.2 EL2 설정

*el2_setup* 프로시저는 하이퍼바이저 동작을 위한 레지스터를 설정한다. 커널이 **EL1**으로 부팅되었다면 **시스템의 엔디안 설정**, **부트 모드를 기록**하는 부분만 수행된다. *CPU_BE*, *CPU_LE* 매크로를 통해 엔디안을 설정한다. 그리고 ***w20* 레지스터에 EL1에서 부팅했음을 기록**하고 리턴한다.

### 2.1.3 CPU 부트 모드 저장

*set_cpu_boot_mode_flag* 프로시저는 CPU 부트 모드를 별도의 변수(*__boot_cpu_mode*)에 저장한다. 저장된 부트 모드는 추후 CPU가 EL1으로 부팅했는지 EL2로 부팅했는지 확인하는 용도로 사용한다. 이 변수는 *.data.cacheline_aligned* 섹션에 저장한다. *.pushsection*은 현재 섹션을 링커 스택에 저장하고 인자로 지정한 섹션으로 전환한다. *popsection*은 이전 섹션을 복원한다. *L1_CACHE_SHIFT* 단위로 정렬하는데 **일반적으로 캐시 라인으로 정렬하면 한 번의 메모리 접근으로 연속된 데이터를 캐시에 올려둘 수 있어 실행 속도의 향상이 가능하다.**











# 리눅스 커널 arm

- 페이지 크기에 따라 가상 주소 공간의 크기가 정해진다? -> p.59
- adrp란 어떤 instruction인가

