---
layout: post
title: "자바 ORM 표준 JPA 프로그래밍 - 기본편 (프록시와 연관관계)"
subtitle: "자바 ORM 표준 JPA 프로그래밍 - 기본편, inflearn"
categories: dev
tags: JPA
---

# 프록시와 연관관계

## 프록시

프로그램과 DB 사이 중간에 위치하여 마치 엔티티 처럼 역할을 수행하면서 DB 조회를 필요할 때까지 미룰 수 있게 해주는 것이 프록시이다

> getReference() 메소드 사용

1. 실제 클래스를 상속 받아서 생성된다
2. 이론적으로 실제 엔티티를 사용하는 것과 구분하지 않고 사용할 수 있다
3. 프록시 객체는 실제 객체의 참조를 보관
4. 프록시 객체를 호출 시 실제 객체의 메소드를 호출



## 프록시의 특징

* 프록시 객체는 처음 사용할 때 **한 번만 초기화**
* 타입 체킹시 원래 엔티티와는 다르기에 instance of 사용해야 한다
* **이미 영속성 컨텍스트에 엔티티가 존재한다면** getReference 메소드를 호출하여도 `실제 엔티티`가 반환된다
* **이미 getReference를 통해 프록시를 초기화 했다면** find 메소드시 같이 `프록시가 반환`된다
* 준영속 상태에서 프록시 초기화는 에러가 발생한다



# 즉시 로딩과 지연 로딩

* 가급적 지연 로딩만 사용
* 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생
* `N+1 문제`를 고려해야 한다

> @ManyToOne, @OneToOne은 즉시 로딩이 기본 -> 지연로딩 사용
>
> @OneToMany, @ManyToMany는 기본이 지연 로딩



## 고려 사항

* 실무에서는 즉시 로딩을 쓰지 않고 항상 지연 로딩을 사용
* `JPQL fetch` 조인 또는 `Entity Graph` 기능을 사용
* 즉시 로딩은 상상하지 못한 쿼리가 나간다



## 영속성 전이: CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만드는 것

> 영속성 전이는 연관관계 매핑과는 아무 관련이 없다
>
> 연관된 엔티티도 함께 영속되는 편리함만을 제공



## 고아 객체

부모 엔티티와 연관관계가 끊어진 자식 엔티티를 말한다

* orphanRemoval

  참조가 제건된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능

> 참조하는 곳이 하나일 때만 사용해야 한다 -> 둘 이상일 경우 제거되면서 Integrity가 깨지면서 Exception이 발생
>
> 즉 특정 엔티티만이 개인 소유할 때 사용 가능하다
>
> @OneToOne, @OneToMany에서만 가능한 기능



* CascadeType.ALL + orphanRemoval = true

  1. 스스로 생명 주기 관리하는 엔티티는 persist 및 remove로 관리
  2. 부모 엔티티를 통해서 자식의 생명 주기 관리
  3. 도메인 주도 설계의 Aggregate Root 개념 구현할 때 유용

  

  

  



