---
layout: post
title: "자바 ORM 표준 JPA 프로그래밍 - 기본편 (다양한 연관관계 매핑, 고급매핑)"
subtitle: "자바 ORM 표준 JPA 프로그래밍 - 기본편, inflearn"
categories: dev
tags: JPA
---

# 연관관계 매핑

## 고려사항

1. 다중성
2. 단방향, 양방향
3. 연관관계의 주인



## 다중성

### 다대일: @ManyToOne

다대일 관계에서는 항상 다 쪽에 외래 키 존재

가장 많이 쓰인다



### 일대다: @OneToMany

단방향에서는 일이 연관관계의 주인이 된다

하지만 외래 키는 항상 다 쪽에 있다. -> 관리를 위한 추가 update sql 실행

> @JoinColumn을 꼭 사용해야 한다. -> 조인 테이블을 추가하는 조인 테이블 방식을 사용하게 된다

일대다 단방향 대신 `다대일 양방향 매핑` 사용 권장

공식적으로는 양방향이 없다



### 일대일: @OneToOne

외래 키에 유니크 제약조건 추가되야 한다

다대일과 유사

> 연관관계 주인이 대상 테이블인 경우 단방향은 JPA 지원하지 않는다

- 주 테이블에 외래 키

  1. 매핑이 편리하다.
  2. 외래 키에 null 허용해야 한다
  3. 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능

  

- 대상 테이블에 외래 키

  1. 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
  2. 지연 로딩으로 설정해도 항상 즉시 로딩됨

  

### 다대다: @ManayToMany

사용하면 안되는 수준

DB에선 정규화된 테이블 2개로 다대다 관계를 표현하지 못하여 `연결 테이블`을 추가해서 일대다, 다대일 관계로 해결한다.

> 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능

@JoinTable로 연결 테이블 지정

1. 연결 테이블에 단순 연결정보만 넣을 수 있음. 다른거 추가 X
2. 쿼리를 정확하게 파악할 수 없음



## 단방향, 양방향

DB는 Foreign key를 통해 양쪽으로 조인이 가능하지만(방향이라는 개념이 없다) 객체는 참조용 필드가 있는 쪽으로만 참조 가능

> 한쪽만 참고하면 단방향
>
> 양쪽이 서로 참조하면 양방향



## 연관관계의 주인

외래 키를 관리하는 참조만이 외래 키에 영향을 주게되고 주인의 반대편은 단순 조회만 가능

> 참조 : [자바 ORM 표준 JPA 프로그래밍 - 기본편 (엔티티 매핑, 연관관계 매핑)]([자바 ORM 표준 JPA 프로그래밍 - 기본편 (엔티티 매핑, 연관관계 매핑) · usan (kimbyungnam.github.io)](https://kimbyungnam.github.io/dev/2021/06/23/jpa-essentials/))



# 상속관계 매핑

DB에는 슈퍼타입과 서브타입이라는 상속과 유사한 기법이 있지만 정확한 상속 관계는 존재하지 않는다. 이를 해결하기 위해서 3가지 방법이 사용된다.

1. 조인 전략 : **JOINED**
2. 단일 테이블 전략 : **SINGLE_TABLE**
3. 각 클래스별 테이블 전략 : **TABLE_PER_CLASS**



## 조인 전략

![조인전략](https://user-images.githubusercontent.com/32065940/123648829-3d32ca00-d864-11eb-803e-fb0ed998e766.png)

부모 클래스를 엔티티로 두고 각각 일대일 연관관계를 맺어서 해결

- 장점
  1. 정규화된 테이블
  2. 외래 키 참조 무결성 제약조건 활용가능
  3. 저장공간 효율화

- 단점
  1. 조회시 조인에 따른 성능 저하
  2. 복잡한 조회 쿼리
  3. 저장시 발생하는 2번의 Insert 쿼리



## 단일 테이블

![단일테이블](https://user-images.githubusercontent.com/32065940/123649174-84b95600-d864-11eb-8f12-9cb8ad2655df.png)

한 테이블의 부모 및 모든 자식 클래스의 값들을 저장

- 장점

  1. 조회 시 조인이 필요없음
  2. 조회 쿼리가 단순함

- 단점

  1. 자식 엔티티의 컬럼은 null이 허용되야 한다

  2. 테이블이 커짐에 따라 조회 성능이 느려질 수 있다

     > 하지만 보통 이 임계점을 잘 넘기지 않는다



## 각 클래스별 테이블 전략

![각클래스별](https://user-images.githubusercontent.com/32065940/123649589-d6fa7700-d864-11eb-91c5-8c31082bf48a.png)

부모 엔티티의 컬럼을 각 자식 엔티티에 다 포함시킨다.

> 추천 하지 않는 방식

- 장점

  1. not null 제약 조건 사용 가능
  2. 서브 타입을 명확하게 구분해서 처리할 때 효과적

- 단점

  1. 여러 자식 테이블을 함꼐 조회할 때 성능이 느리다(UNION 필요)

     > ex. 부모 엔티티 컬럼에 의한 조회시

  2. 자식 테이블을 통합해서 쿼리하기 어렵다



## @MappedSuperclass

공통으로 사용되는 매핑 정보만 필요할 때 사용

> DB에는 각 클래스별 테이블 전략 처럼 컬럼들이 각각 들어가게 된다
>
> 보통 생성날 짜 등 공통으로 들어가야 하는 부분이 있을 경우 사용된다

@Entity 클래스는 **엔티티** 또는 **@MappedSuperclass**로 지정된 클래스만 `상속 가능`



### 주의 사항

1. 상속관계 매핑이 아니다
2. 엔티티가 아니므로 테이블과 매핑 되지 않는다
3. 조회, 검색 불가
4. 추상 클래스 권장
